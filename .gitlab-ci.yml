stages:          # List of stages for jobs, and their order of execution
  - build
  - deploy

build: # temp job
  stage: build
  script:
    - echo 'hello there'

build: # temp job
  stage: build
  script:
    - echo 'hello there'
    
# build:
#   stage: build
#   image:
#     name: gcr.io/kaniko-project/executor:v1.9.0-debug 
#     entrypoint: [""]
#   script:  # See https://docs.gitlab.com/ee/ci/docker/using_kaniko.html                
#     - /kaniko/executor
#       --context "${CI_PROJECT_DIR}"  
#       --dockerfile "${CI_PROJECT_DIR}/Dockerfile.production"
#       --destination "${CI_REGISTRY_IMAGE}/taskit:${CI_COMMIT_TAG:-latest}"            # Tags with "latest" if untagged commit. 

# deploy:
#   stage: deploy
#   image:
#     name: gcr.io/k8s-skaffold/skaffold:v2.0.0  # TODO: replace with a better Kubernetes image. Bitnami?
#     entrypoint: ['']
#   environment:
#     name: production
#     url: $TASKIT_URL # TODO: Set as environment variable. URL to your application. Ie HTTP://cscloud6-25.lnu.se
#   when: manual
#   script:
#     - kubectl config get-contexts
#    # Configure kubectl to use our own k8s cluster, you need to setup an Gitlab agent in you k8s kluster
#     - kubectl config use-context $K8S_CONTEXT
#    # Authorize the cluster to pull images from our registry. (synced against Deploy Token "gitlab-deploy-token")
#     - kubectl delete secret regcred || true
#     - kubectl create secret docker-registry regcred --docker-server=$CI_REGISTRY --docker-username=$CI_DEPLOY_USER --docker-password=$CI_DEPLOY_PASSWORD
# 
#     - kubectl apply -f ./k8s/taskit.yaml -f ./k8s/mongodb.yaml -f ./k8s/redis.yaml # We are skipping ingress for now # TODO: replace this with real services
#     
#    # Debugging outputs after completion
#     - kubectl get deployments
#     - kubectl get services
#     - kubectl get pods
